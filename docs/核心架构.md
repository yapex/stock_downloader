# 核心架构分析

本文档详细描述了 `stock_downloader` 项目的核心架构、主要组件及其交互方式。

## 1. 架构风格

本项目采用**依赖注入 (Dependency Injection, DI)** 作为其核心架构风格。通过 `dependency-injector` 库实现，这种模式遵循**控制反转 (Inversion of Control, IoC)** 原则。

- **中心化容器**: 应用的核心是一个名为 `AppContainer` 的DI容器 (`src/neo/containers.py`)。这个容器负责实例化和管理所有服务的生命周期（例如，单例或工厂模式）。
- **松耦合**: 组件不直接创建其依赖项，而是通过容器注入。这大大降低了模块间的耦合度，使得代码更易于测试、维护和扩展。
- **单一真相来源**: 所有服务实例都由 `AppContainer` 创建和提供，确保了在应用的任何地方（包括主进程和后台任务）使用的都是同一个配置好的实例。

## 2. 核心组件详解

以下是构成应用的主要组件及其职责，它们都在 `AppContainer` 中定义。

| 组件 | 类型 | 职责 | 依赖项 |
| :--- | :--- | :--- | :--- |
| `AppContainer` | Container | DI容器，定义并提供所有应用服务。 | - |
| `FetcherBuilder` | Factory | 创建数据获取器 (Fetcher)。这使得系统可以灵活地扩展以支持不同的数据源或API。 | - |
| `RateLimitManager` | Singleton | 管理API请求的速率限制，防止因请求过于频繁而被目标服务器阻止。 | - |
| `DBOperator` | Factory | 提供数据库操作服务，封装了数据库连接、数据写入、表创建等SQL操作。 | - |
| `SchemaLoader` | Singleton | 从配置文件（如 `stock_schema.toml`）加载数据库表结构定义。 | - |
| `SimpleDownloader` | Singleton | 核心下载器服务，协调整个下载过程。 | `FetcherBuilder`, `RateLimitManager`, `DBOperator` |
| `AsyncSimpleDataProcessor` | Factory | 异步处理下载到的原始数据，可以进行数据清洗、转换，并最终存入数据库。 | `DBOperator`, `SchemaLoader` |
| `TaskBuilder` | Singleton | 根据用户输入的参数（如股票代码、任务类型）构建具体的下载任务对象列表。 | - |
| `GroupHandler` | Singleton | 处理在配置文件中定义的“任务组”，允许用户通过一个组名来下载一批预设的股票和数据类型。 | - |
| `TasksProgressTracker` | Singleton | 跟踪所有任务的执行进度，并通过 `rich` 或 `tqdm` 等库在命令行界面上提供实时反馈。 | `ProgressTrackerFactory` |
| `AppService` | Singleton | 应用层服务，作为顶层协调者，驱动整个下载流程的执行。 | `TasksProgressTracker` |

## 3. 核心逻辑流程

应用的典型执行流程如下，以用户执行 `dl` 命令为例：

1.  **启动**: 用户在命令行中执行 `python -m neo.main dl --group <group_name>`。
2.  **入口点**: `typer` 解析命令，调用 `main.py` 中的 `dl` 函数。
3.  **获取服务**: `dl` 函数从全局的 `AppContainer` 实例中请求 `group_handler`, `task_builder`, 和 `app_service`。
4.  **解析任务组**: `group_handler` 读取配置文件，根据用户提供的 `<group_name>` 获取对应的股票代码列表和任务类型列表。
5.  **构建任务**: `task_builder` 接收股票代码和任务类型，创建一系列具体的下载任务对象。
6.  **执行下载**: `app_service` 接收任务列表，并调用 `downloader` 来执行它们。
7.  **获取数据**:
    - `downloader` 使用 `fetcher_builder` 为每个任务创建一个合适的 `fetcher`。
    - `fetcher` 向外部数据源（如 Tushare API）发起请求。
    - `rate_limit_manager` 确保请求频率在允许的范围内。
8.  **处理和存储数据**:
    - 下载的原始数据被传递给 `data_processor`。
    - `data_processor` 进行异步处理（如数据格式转换）。
    - `db_operator` 利用 `schema_loader` 加载的表结构，将处理后的数据写入数据库（如 DuckDB）。
9.  **进度反馈**: 在整个过程中，`tasks_progress_tracker` 持续更新命令行界面，向用户展示任务的实时进度。

这个架构通过将不同的职责清晰地分离到各个独立的组件中，实现了高度的模块化和可维护性。
